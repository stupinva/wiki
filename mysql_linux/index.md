Настройка Linux для MySQL
=========================

[[!tag mysql linux]]

Содержание
----------

[[!toc startlevel=2 levels=4]]

Общие рекомендации
------------------

Рекомендации по настройке Linux для MySQL:

- использовать свежие ядра Linux,
- использовать опции монтирования `noatime` и `nodiratime`,
- поменять планировщик ввода-вывода с Completely Fair Queueing (CFQ) на Noop или Deadline,

Защита от вытеснения в область подкачки
---------------------------------------

### Настройка переменной ядра

Первым делом выставим переменную ядра `vm.swappiness`, указывающую стоимость ввода-вывода с областью подкачки относительно стоимости ввода-вывода с файловой системой. Переменная должна принимать значение от 0 до 200, где 100 означает равную стоимость ввода-вывода с областью подкачки и стоимость ввода-вывода с файловой системой. Значение по умолчанию равно 60. Значение 0 предписывает использовать раздел подкачки только в случае нехватки оперативной памяти. Такое значение использовать не рекомендуется, т.к. для подкачки будут использоваться области памяти разделяемых библиотек и выполняемых файлов, которые в любой момент можно загрузить с диска, в ущерб вытеснению неиспользуемых областей данных. Выставим переменной `vm.swappiness` значение 1:

    # sysctl -w vm.swappiness=1

И пропишем это значение в файл `/etc/sysctl.conf`, чтобы оно восстанавливалось при загрузке системы:

    vm.swappiness = 1

### Настройка прямого ввода-вывода

Механизм хранения InnoDB по умолчанию пишет данные на диск через кэш файловой системы. При записи через кэш файловой системы создаётся в нём оседают записываемые блоки информации, которые уже есть в буферном пуле самого механизма хранения InnoDB. Копии данных в кэше файловой системе остаются невостребованными, но заставляет операционную систему использовать больше оперативной памяти для размещения кэша файловой системы и вытеснять в облать подкачки те редко используемые копии данных, которые находятся в буферном пуле InnoDB. Чтобы снизить востребованность кэша файловой системы и уменьшить давление на области памяти буферного пула InnoDB, приводящее к их вытеснению в область подкачки, поменяем режим записи изменённых страниц InnoDB на прямой, не использующий кэш файловой системы. Для этого пропишем в файле конфигурации MySQL следующую опцию:

    innodb_flush_method = O_DIRECT

Чтобы новые настройки вступили в силу, можно перезапустить MySQL:

    # systemctl restart mysql

### Настройка чередования областей памяти

На несимметричных многопроцессорных системах каждый из процессоров имеет прямой доступ к областям памяти, подключенным непосредственно к контроллеру памяти, находящемуся в процессоре. Для обращения к областям памяти, подключенным к контроллерам памяти другого процессора, один процессор должен запросить данные у другого процессора. Доступ к областям памяти другого процессора занимает больше времени, из-за чего такая многопроцессорная система и называется несимметричной.

Обычно в таких многопроцессорых системах в слоты каждого из процессоров устанавливают равный объём оперативной памяти. При запуске MySQL может запросить для хранения буферного пула InnoDB объём памяти, превышающий объём оперативной памяти, соответствующей одному процессору. В таком случае в первую очередь запрос удовлетворяется за счёт областей памяти, доступных первому процессору, а остальной объём удовлетворяется за счёт областей памяти следующих процессоров. В результате оказывается, что у первых процессоров весь объём памяти оказывается распределён, а свободная память остаётся только у последних процессоров.

Когда потоку MySQL, выполняющемуся на первом процессоре, понадобится выделить дополнительную область памяти, она будет распределена в объёме оперативной памяти, соответствющем одному из последних процессоров. В итоге поток будет вынужден работать с медленной оперативной памятью, которая доступна не через локальный контроллер оперативной памяти, а через контроллер оперативной памяти другого процессора.

Операционная система стремится ускорить работу потока и стремится вытеснить в раздел подкачки редко используемые области локальной памяти процессора и переместить данные из области памяти другого процессора в область памяти, доступную локально. Это, в свою очередь, опять снижает эффективность буферного пула InnoDB, т.к. его данные оказываются вытесненными на диск.

Чтобы избежать подобной ситуации, можно прописать в файле конфигурации MySQL опцию для удовлетворения запросов в оперативной памяти не последовательным распределением областей памяти, доступных каждому из процессоров, а за счёт использования фрагментов из областей памяти разных процессоров. В таком случае у каждого из процессоров остаётся свободная локальная оперативная память, которую можно использовать для удовлетворения запросов на выделение памяти для потоков, выполняющихся на этом процессоре. Пропишем в файле конфигурации MySQL следующую опцию:

    innodb_numa_interleave = ON

Чтобы новые настройки вступили в силу, можно перезапустить MySQL:

    # systemctl restart mysql

### Фиксация областей памяти от вытеснения

Если на сервере кроме MySQL выполняются другие процессы, например, резервное копирование, то для их работы может потребоваться оперативная память, а выполняемые ими операции ввода-вывода создают потребность в файловом кэше. Для ускорения операций ввода-вывода операционная система будет стремиться вытеснить редко используемые области оперативной памяти в раздел подкачки, как это было описано выше. Часто такими областями памяти оказываются фрагменты буферного пула InnoDB, что отрицательно скажется на производительости системы в тот момент, когда данные из буферного пула окажутся востребованными. Для того, чтобы избежать выгрузки областей оперативной памяти, распределённых для буферного пула InnoDB, нужно включить в файле конфигурации MySQL следующую опцию:

    memlock = ON

К сожалению, в документации MySQL написано, что для её использования процесс MySQL должен быть запущен с правами пользователя root. К счастью, в Linux существует механизм Capabilities, с помощью которого можно разрешить пользователю выполнять отдельные операции, доступны только пользователю root. В данном случае для выполнения операций фиксации областей памяти в оперативной памяти необходима привилегия CAP_IPC_LOCK. Включить её можно воспользовавшись средствами systemd. Отредактируем имеющийся в системе service-файл с помощью следующей команды:

    # systemctl edit --full mysql

Имеющийся системный файл `/lib/systemd/system/mysql.service` будет скопирован в `/etc/systemd/system/mysql.service`, после чего для его редактирования будет вызван редактор по умолчанию. Найдём в файле секцию `[Service]` и добавим в неё опцию:

    AmbientCapabilities=CAP_IPC_LOCK

Теперь нужно сообщить systemd о появлении обновлений в файлах конфигурации, для чего выполним следующую команду:

    # systemctl daemon-reload

Чтобы новые настройки вступили в силу, можно перезапустить MySQL:

    # systemctl restart mysql

### Использование огромных страниц

Поддержка виртуальной памяти микропроцессором основывается на использовании каталога страниц, в котором по виртуальному адресу можно найти физический адрес оперативной памяти. Каталог представляет собой иерахическую структуру данных. Виртуальный адрес разбивается на несколько фрагментов, старший фрагмент адреса используется в качестве индекса страницы в каталоге первого уровня, из которого извлекается физический адрес страницы каталога второго уровня. Следующий фрагмент адреса ищется в странице каталога второго уровня и т.д. В последней странице находится физический адрес искомой области памяти.

Поскольку СУБД распределяет большие объёмы оперативной памяти, было бы неплохо воспользоваться возможностью увеличить размер страницы, уменьшив количество уровней в каталоге страниц. Таким образом будет с одной стороны уменьшена фрагментация оперативной памяти, а с другой стороны - увеличена скорость поиска физических адресов по виртуальным. И такая возможность поддерживается как самим микропроцессором, так и ядром операционной системы. Сократив глубину каталога страниц на один уровень, можнео перейти от страниц размером 4 килобайта к страницам размером 2 мегабайта. Сократив глубину каталога ещё на один уровень, можно перейти к использованию страниц размером 1 гигабайт.

Дополнительный плюс от использования огромных страниц заключается в том, что они не выгружаются в область подкачки. Перед тем, как включить огромные страницы, нужно настроить пул страниц и группу пользователей, которым они будут доступны.

Посмотрим на состояние огромных страниц в системе:

    $ grep -i ^HugePages /proc/meminfo
    HugePages_Total:       0
    HugePages_Free:        0
    HugePages_Rsvd:        0
    HugePages_Surp:        0
    Hugepagesize:       2048 kB

Здесь:

* `HugePages_Total` - общее количество огромных страниц в пуле,
* `HugePages_Free` - количество свободных огромных страниц,
* `HugePages_Rsvd` - количество зарезервированных огромных страниц, которые были уже выделены, но пока свободны,
* `HugePages_Surp` - количество огромных страниц, которые были сформированы из пула обычных страниц,
* `Hugepagesize` - размер одной огромной страницы.

Узнаем объём буферного пула InnoDB:

    $ mysql -BNe "SHOW GLOBAL VARIABLES WHERE variable_name='innodb_buffer_pool_size'" | awk '{ print $2; }'

Посчитаем требуемое общее количество огромных страниц в пуле как `innodb_buffer_pool_size / Hugepagesize` и присвоим получившееся значение переменной ядра `vm.nr_hugepages`:

    # sysctl -w vm.nr_hugepages=65536

При выполнении этой команды страницы из общего пула будут собраны в огромные страницы и переведены в пул огромных страниц. Убедитесь в том, что в системе есть достаточный объём оперативной памяти или места в области подкачки.

Узнаем идентификатор группы `mysql` с помощью следующей команды:

    $ id -g mysql

И назначим этот идентификатор в качестве группы владельца пула огромных страниц:

    $ sysctl -w vm.nr_hugepages=111

Вместо этого можно дать пользователю MySQL права `CAP_IPC_LOCK`, как это было описано выше.

Описанные выше расчёты и настройки можно произвести с помощью следующего скрипта:

    #!/bin/sh
    
    innodb_buffer_pool_size=`mysql -BNe "SHOW GLOBAL VARIABLES WHERE variable_name='innodb_buffer_pool_size'" | awk '{ print $2; }'`
    hugepage_size=`awk '/^Hugepagesize: / { print $2 * 1024; } ' < /proc/meminfo`
    hugepages=$((innodb_buffer_pool_size / hugepage_size))
    mysql_group_id=`id -g mysql`
    
    echo "Add or update follow lines in /etc/sysctl.conf:"
    sysctl -w vm.nr_hugepages=$hugepages
    sysctl -w vm.hugetlb_shm_group=$mysql_group_id

Чтобы эти настройки применялись при загрузке системы, нужно прописать их в файле `/etc/sysctl.conf`.

Далее в файле конфигурации MySQL пропишем опцию, предписывающую использовать огромные страницы:

    large_pages = ON

И теперь можно перезапустить MySQL, чтобы буферный пул InnoDB начал использовать огромные страницы:

    # systemctl restart mysql

Убедиться в том, что огромные страницы начали использоваться, можно сравнив значения `HugePages_Total`, `HugePages_Free` и `HugePages_Rsvd`. Количество свободных страниц должно быть меньше общего количества, а количество зарезервированных - меньше количества свободных.

### Отключение прозрачных огромных страниц

При использовании прозрачных огромных страниц система сама пытается сформировать из обычных страниц огромную страницу, для чего внутри ядра Linux предназначены потоки с именами `kswapd`, `defrag`, `kcompactd`, `khugepaged`. Формирование огромных страниц из обычных может создавать дополнительную нагрузку на центральный процессор, а сами такие страницы не защищены от вытеснения в область подкачки. К тому же, при выгрузке в область подкачки, огромная страница снова разбивается на обычные страницы.

Отключим прозрачную поддержку огромных страниц (Transparent Hugepages). Для этого выполним следующие команды:

    # echo never > /sys/kernel/mm/transparent_hugepage/enabled
    # echo never > /sys/kernel/mm/transparent_hugepage/defrag

Чтобы не нужно было выполнять эти действия после перезагрузки системы, передадим опцию ядру операционной системе при его загрузке. Для этого открываем файл `/etc/default/grub`, находим переменную `GRUB_CMDLINE_LINUX` и добавляем в список опций опцию `transparent_hugepage=never`. В результате должно получиться что-то такое:

    GRUB_CMDLINE_LINUX="ipv6.disable=1 transparent_hugepage=never"

Обновим конфигурацию загрузчика следующей командой:

    # update-grub

Использованные материалы
------------------------

* [Muhammad Irfan. InnoDB Performance Optimization Basics](https://www.percona.com/blog/2013/09/20/innodb-performance-optimization-basics-updated/)
* [Ibrar Ahmed. Settling the Myth of Transparent HugePages for Databases](https://www.percona.com/blog/settling-the-myth-of-transparent-hugepages-for-databases/)
* [Peter Zaitsev. Best Practices for Configuring Optimal MySQL Memory Usage](https://www.percona.com/blog/best-practices-for-configuring-optimal-mysql-memory-usage/)
* [MySQL 5.7 Reference Manual  /  ...  /  Enabling Large Page Support](https://dev.mysql.com/doc/refman/5.7/en/large-page-support.html)
* [MySQL 8.0 Reference Manual  /  ...  /  Enabling Large Page Support](https://dev.mysql.com/doc/refman/8.0/en/large-page-support.html)
* [Using mlock ulimits for SHM_HUGETLB deprecated](https://bugs.mysql.com/bug.php?id=51597)

Дополнительные материалы
------------------------

* [Documentation for /proc/sys/vm/swappiness](https://docs.kernel.org/admin-guide/sysctl/vm.html#swappiness)
* [В защиту swap'а [в Linux]: распространенные заблуждения](https://habr.com/ru/companies/flant/articles/348324/)
* [Джастин Эллингвуд. Использование Systemctl для управления службами и блоками Systemd](https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units-ru)
* [HugeTLB Pages](https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html)
