Скрипты для удобного развёртывания реплики MySQL с помощью снимков LVM
======================================================================

В статье [[Настройка реплики MySQL с помощью снимков LVM и rysnc|mysql_slave_lvm_rsync]] описана процедура ручного развёртывания реплики из копии основного сервера MySQL. Пользуясь для развёртывания реплики утилитой `xtrabackup`, легко привыкнуть к её простоте. После неё ручная процедура развёртвывания реплики из копии основного сервера MySQL кажется довольно многоступенчатой. Для автоматизации развёртывания реплики можно прибегнуть к скрипту, описанному в статье [[Периодическое резервное копирование MySQL с помощью снимков LVM|mysql_periodic_lvm_backup]], немного доработав его.

В результате доработки у меня получились скрипты [[lvsend.sh]] и [[lvrecv.sh]]. Первый скрипт использует те же настройки из файла `/etc/lvbackup.conf`, за исключением настроек размещения локальной резервной копии и архивации резервной копии на удалённый сервер. Из всех настроек скрипта `lvbackup.sh` скрипт `lvsend.sh` использует только следующие:

* `PVNAME` - группа томов, на которой находятся файлы баз данных MySQL,
* `LVNAME` - логический том, на котором находятся файлы баз данных MySQL,
* `LVSNAP` - имя логического тома с мгновенным снимком, который будет создан во время работы скрипта,
* `SNAP_PATH` - каталог, в который нужно смонтировать мгновенный снимок для копирования,
* `SRC` - относительный путь к каталогу с файлами баз данных на смонтированном мгновенном снимке. Если файлы баз данных находятся прямо в корне раздела, то в качестве имени можно указать точку - обозначение текущего каталога.

Скрипт `lvrecv.sh` настолько прост, что я не стал выносить его настройки в отдельный файл - проще исправить его настройки прямо внутри самого скрипта.

Если реплика ранее уже была настроена, но необходимо развернуть её повторно, то перед началом работ лучше сохранить права доступа, например, при помощи утилиты `pt-show-grants`:

    # pt-show-grants > grants.sql

Также нам понадобится информация об источнике репликации и пользователе, от имени которого реплика забирает журналы с источника. Эти данные можно взять из файла `master.info`. Например, вот так можно сохранить адрес исходного сервера, имя пользователя, от имени которого происходит репликация, его пароль и номер порта на исходном сервере, если он отличается от порта по умолчанию 3306:

    # awk 'NR>3 && NR<8 { print $0; }' /var/lib/mysql/master.info
    192.168.0.101
    repl
    p4$$w0rd
    3306

Пользоваться скриптами нужно в следующей последовательности:

- Сначала проверить настройки в скрипте `lvrecv.sh` на реплике, при необходимости поправив их. Если на реплике нет достаточно места для второй копии баз данных, то нужно остановить MySQL и удалить его данные. Затем узнаём IP-адрес сервера, например, с помощью команды `ip addr show` и запускаем скрипт. Скрипт будет ожидать поступления одного входящего подключения на TCP-порт (по умолчанию в скрипте указан порт 4444).
- На сервере-источнике размещаем скрипт `lvsend.sh` и файл `/etc/lvbackup.conf` с его настройками. Проверяем настройки в файле конфигурации, при необходимости исправляем и запускаем скрипт следующим образом:

    # ./lvsend.sh me <IP-адрес_реплики> 4444

Теперь ждём завершения обоих скриптов. Скрипт `lvsend.sh` выдаст позицию в журнале репликации, с которой реплика может продолжить отслеживать изменения на сервере-источнике.

На реплике по умолчанию создаётся каталог с именем `mysql.new`. Если MySQL на реплике ещё не остановлен, самое время остановить его, удалить его файлы данных и посдтавить вместо них каталог `mysql.new`. Из этого каталога нужно удалить файл `auto.cnf`, после чего запустить MySQL на реплике снова.

Осталось подключиться консольным клиентом MySQL к реплике, указать настройки источника и запустить репликацию:

    mysql> CHANGE MASTER TO MASTER_HOST = '192.168.0.101',
                            MASTER_USER = 'repl',
                            MASTER_PASSWORD = 'xxxxxxxxxx',
                            MASTER_LOG_FILE = 'bin-log.001038',
                            MASTER_LOG_POS = 96682764;
    mysql> START SLAVE;

За процессом репликации можно наблюдать при помощи команды следующего вида:

    # watch "mysql -Be 'SHOW SLAVE STATUS\G' | grep Seconds_Behind_Master"

Она выводит количество секунд, на которое реплика отстаёт от источника. Когда отставание станет нулевым, можно считать реплику полностью синхронизированной с источником. Если же вместо числа выводится значение NULL, то процесс синхронизации по каким-то причинам не активен. Стоит посмотреть на полный вывод запроса SHOW SLAVE STATUS\G.
