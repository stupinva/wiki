Архивация периодических таблиц MySQL
====================================

[[!tag mysql]]

Введение
--------

Некоторые приложения записывают в базу данных события, привязанные к определённой дате. Как правило, наиболее востребованными данными являются самые свежие данные. Но при росте объёма данных в таблице замедляется поиск, даже при наличии подходящего индекса. Дело в том, что индекс может не помещаться целиком в оперативной памяти или вытесняется на диск более востребованными данными, а необходимость обновлять большой индекс при вставке новых данных в таблицу приводит к замедлению операций вставки.

Для решения этой проблемы в настоящее время обычно используют деление таблицы на отдельные секции, соответствующие году, месяцу или суткам. У каждой секции при этом имеется собственный индекс, поэтому при добавлении в таблицу новых данных нужно обновлять только индекс последней секции таблицы. Самые востребованные данные также как правило находятся в последней секции таблицы.

Но до появления поддержки секций таблиц в MySQL разработчикам приложений приходилось решать эту задачу самостоятельно. Одним из таких приложений является биллинговая система [BGBilling](https://bgbilling.ru/). В ней для хранения периодических данных используются отдельные таблицы с именами, оканчивающимися шестью или восемью цифрами, соответствующими определённому месяцу или суткам. Такой же подход к хранению периодических данных используется в ERP-системе [BGERP](https://bgerp.ru/). Мне попадалась ещё одна система собственной разработки, разработчик которой черпал вдохновение из одной из упомянутых двух программ.

Поскольку приложение лишь добавляет данные в эти таблицы, но не удаляет, количество таблиц со временем растёт вместе с занимаемым ими местом на диске. Поэтому устаревшие таблицы имеет смысл удалять. Однако не всегда эти таблицы стоит удалять окончательно. Во-первых, таблицу можно удалить по ошибке. Во-вторых, могут возникнуть исключительные ситуации, в которых может понадобиться найти информацию в давно устаревших данных.

Для решения задачи архивации периодических таблиц я написал настраиваемый скрипт [[archive_tables.sh]], который использует файл конфигурации `/etc/archive_tables.conf`.

Предполагается, что скрипт может быть настроен на произвольном сервере. Команды удаления устаревших таблиц должны выполняться на основном сервере MySQL, а для снятия резервных копий таблиц может использоваться сервер-реплика. Сжатые резервные копии могут отправляться на удалённый сервер по протоколу SSH. Но скрипт можно настроить так, чтобы он работал в рамках одного сервера и хранил архивы таблиц локально.

Подготовка пользователя на ведущем сервере
------------------------------------------

Предполагается, что скрипт запускается на сервере, который реплицирует базы данных с основного сервера. В таком случае на основном сервере нужно создать пользователя с правами `SELECT`, `DROP` и `ALTER` для всех баз данных, таблицы из которых предполагается архивировать.

Предположим, что IP-адрес основного сервера - `192.168.1.2`, а IP-адрес сервера-реплики - `192.168.1.3`. Предположим также, что пользователь будет называться `archive`, а его пароль - `p4$$w0rd`. В таком случае создать пользователя на основном сервере можно с помощью одного из следующих запросов:

    GRANT USAGE ON *.* TO `archive`@`192.168.1.3` IDENTIFIED BY 'p4$$w0rd';
    CREATE USER `archive`@`192.168.1.3` IDENTIFIED BY 'p4$$w0rd';

Пользователь будет обрабатывать таблицы базы данных `ufadisc`. Выдать необходимые права доступа к этой базе данных можно с помощью запроса следующего вида:

    GRANT SELECT, DROP, ALTER ON `ufadisc`.* TO `archive`@`192.168.1.3`;

Не забудьте после этого применить изменения с помощью следующей команды;

    FLUSH PRIVILEGES;

Подготовка пользователя на ведомом сервере
------------------------------------------

В домашнем каталоге пользователя, от имени которого будет работать скрипт архивации таблиц, нужно создать файл `~/.my.cnf`, аналогичный описанному выше файлу `/etc/mysql/archive.cnf`, в котором нужно указать учётные данные для подключения к серверу-реплике. Пользователю нужно выдать глобальные права `SHOW DATABASES` и `RELOAD`, и права `SELECT`, `LOCK TABLES` для резервного копирования таблиц каждой из баз данных.

Сначала создадим пользователя одной из следующих команд:

    GRANT USAGE ON *.* TO `archive`@`localhost` IDENTIFIED BY 'p4$$w0rd';
    CREATE USER `archive`@`localhost` IDENTIFIED BY 'p4$$w0rd';

Выдадим глобальные права доступа:

    GRANT SHOW DATABASES, RELOAD ON *.* TO `archive`@`localhost`;

Выдадим права доступа к базе данных:

    GRANT SELECT, LOCK TABLES ON `ufadisc`.* TO `archive`@`localhost`;

Подготовка пользователя на архивном сервере
-------------------------------------------

В качестве сервера для хранения архивов может выступать любой Unix-сервер, поддерживающий доступ по SSH. В случае с Linux создать на нём пользователя, от имени которого к нему будет подключаться скрипт архивации, можно следующим образом:

    # groupadd archive
    # useradd -c "User for store archive tables" -d /home/archive -m -g archive archive

В случае с FreeBSD соответствующие команды будут иметь следующий вид:

    # pw add group archive
    # pw add user archive -g archive -c "User for store archive tables" -d /usr/home/archive -m

Теперь вернёмся к серверу, на котором будет выполняться скрипт и от имени пользователя, под которым будет работать скрипт,  сгенерируем SSH-ключ для доступа из скрипта к удалённому серверу:

    # ssh-keygen -N "" -f ~/.ssh/archive

Скопируем публичный ключ из файла `~/.ssh/archive.pub`. Далее вернёмся на сервер, на который будем записывать архивы. Создадим на нём файл с ключами, владельцам которых разрешён вход по SSH от имени созданного пользователя:

    # mkdir /home/archive/.ssh
    # chown archive:archive /home/archive/.ssh
    # cat <<END > /home/archive/.ssh/authorized_keys
    ТУТ ПУБЛИЧНЫЙ SSH-КЛЮЧ  
    END
    # chown archive:archive /home/archive/.ssh/authorized_keys

Настройка скрипта
-----------------
