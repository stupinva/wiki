Структурированная документация по конфигурации mathopd.conf
===========================================================

[[!toc startlevel=2 levels=4]]

Опции рассортированы по секциям файла конфигурации, к которым они относятся. Для каждой опции указано её значение по умолчанию. Тип значения не указывается, т.к. очевиден из значения по умолчанию.

Секция Global
-------------

Это условная секция, которая в явном виде в файле конфигурации не указывается. Опции, относящиеся к этой условной секции, указываются вне какой-либо секции.

### Управление журналами

#### ErrorLog (строка)

Процесс сервера будет выводить диагностические сообщения в этот файл. Mathopd откроет журнал ошибок в режиме только для записи. Если для этого не хватит прав, программа завершит работу. Отметим, что если значение ErrorLog содержит знак процента (%), имя файла журнала ошибок будет дополнено с использованием конструкций strftime (смотрите также: Log.)

#### Log (строка)

Это ключевое слово определяет где хранится журнал доступа. Сервер создаёт один и только один журнал доступа, вне зависимости от количества (виртуальных) серверов. Файл журнала должен быть доступен на запись пользователю, от имени которого запускается сервер. Если файл журнала не существует, mathopd попытается его создать. В этом случае сервер должен также иметь права записи в каталог, содержащий файл журнала. Существуют некоторые уловки, позволяющие облегчить сопровождение журналов для различения периодов времени. Перед попыткой открытия файла журнала Mathopd раскрывает конструкции с ’%’ в имя файла журнала, таким же образом, как это делает date(1) и strftime(3). Например, если указано

`Log /var/mathopd/log.%Y%m%d`

mathopd раскроет %Y, %m и %d в имени файла во что−то подобное /var/mathopd/log.20020831 Mathopd автоматически вращает файл журнала каждый час. Если во время этого процесса Mathopd по какой−либо причине не сможет создать новый файл журнала, он продолжит дописывать старый журнал. Формат журнала доступа определяется описанием в блоке LogFormat (смотрите далее.)

#### LogGMT = Off

Обычно отметка времени в файлах журнала делается по локальному часовому поясу. Если LogGMT установлено в ’On’, отметки времени делаются по гринвичскому часовому поясу. Отметим, что эта настройка также влияет на имена файлов журналов, если в них используется конструкция с символом "%". (См. ключевое слово Log.)

### Безопасность

#### StayRoot = Off

Если Mathopd запущен от имени пользователя root, сменит свой идентификатор на непривелигированного пользователя (смотрите ключевое слово User). Иногда это бывает желательным для удержания некоторых привилегий пользователя root, например если запускаются внешние процессы. На самом деле не нужно, чтобы дочерние процессы имели возможность мешать самому процессу сервера, поэтому эти процессы должны запускаться под другим идентификатором. Для достижения этого установите переключатель StayRoot.

#### User (строка)

Если Mathopd запущен пользователем root, он должен сменить свой идентификатор. Это делается из соображений безопасности: вам не нужен сервер, который может читать любые файлы. Новый идентификатор указывается значением ключевого слова User. Имя пользователя ищется в файле паролей (это делается до возможной смены корневого каталога с помощью chroot!), а затем Mathopd меняет свой эффективный идентификатор пользователя (и реальный идентификатор, в зависимости от значения StayRoot). Доплнительно, Mathopd выполняет вызов setgroups(), чтобы очистить список дополнительных идентификаторов групп.

Замечание: Mathopd создаёт файлы журнала и т.п. делая их владельцем пользователя, указанного в ключевом слове User. *Группа* владеющая файлом журнала может отличаться в зависимости от операционной системы. Например, в BSD группа владеющая файлом берётся из группы владеющей каталогом, в котором создан файл. Другие системы могут иметь другую семантику.

#### Umask = 022

Mathopd создаст файлы журнала с данными правами доступа. Эти разрешения определяются так называемыми в жаргоне Unix ’umask’. umask со значением 022 (по умолчанию) создаст файл, который будет доступен для чтения всем, но будет доступен для записи только пользователю, который запустил процесс сервера. Более ограничивающие umask − это 026 или 066. (0 в начале обязателен!)

Замечание: umask наследуется дочерними процессами.

#### RootDirectory (строка)

Если встретилось это ключевое слово, mathopd выполнит chroot() в указанный каталог перед запуском. chroot() выполняется сразу после чтения файла конфигурации. Обычно чтобы это сработало, сервер должен быть запущен от имени пользователя root. В новом корне могут потребоваться некоторые дополнительные файлы, например (с обрезанным путём) /etc/passwd и т.п.

### Общие настройки

#### CoreDirectory (строка)

Обычно, в практических целях, сервер меняет свой текущий каталог на корневой каталог "/". Если это нежелательно по некоторым причинам, можно указать здесь другой каталог. Побочным эффектом этого будет то, что если mathopd по некоторым причинам сбросит образ процесса на диск, файл с образом процесса попадёт в этот каталог. На самом деле, если сервер запускается от имени пользователя root, он никогда не сбрасывает образ процесса на диск из соображений безопасности, поэтому иногда данная возможность бесполезна.

#### PIDFile (строка)

Ключевое слово PIDFile указывает файл, в который сервер запишет идентификатор своего процесса, в целях его отслеживания.

Секция Tuning
-------------

Здесь могут быть указаны опции для тонкой настройки сервера.

### Принятие подключений

#### AcceptMulti = On

По умолчанию, mathopd пытается принять дополнительные соединения, после того как он принял одно, до тех пор пока принятые вызовы не приведут к блокировке. При затруднении трафика, это означает что при каждом входящем подключении будет выполняться дополнительный системный вызов. Если это поведение не желательно, воспользуйтесь этим ключевым словом для его отключения.

#### Clobber = On

Обычно Mathopd закрывает простаивающие соединения тогда, когда уже достигнуто максимальное количество соединений и поступает новое входящее соединение. Это поведение называется ’сбиванием’ (’clobbering’). При установке переключателя ’Clobber’ в состояние ’Off’, новые соединения не будут устанавливаться, пока не закроются имеющиеся соединения или пока не будет достигнут их тайм−аут.

### Управление потреблением памяти

#### NumConnections = 64

Параметр NumConnections определяет количество одновременно обрабатываемых запросов. Значение по умолчанию возможно слишком низкое для систем с высоким трафиком. Mathopd использует фиксированный блок памяти для каждого соединения, поэтому чем большее значение настроено в этом параметре, тем больше памяти сервер будет использовать.

Смотри также: Clobber.

Замечание: общее количество памяти, используемое Mathopd для буферов, может быть приблизительно посчитано по следующей формуле:

`Memory = NumConnections * (BufSize + InputBufSize + 2 * ScriptBufSize)`

#### BufSize = 12288

Сервер использует два буфера для хранения входящих и исходящих данных. Размер исходящего буфера определяется значением ключевого слова BufSize. Буферы большего размера могут привести к уменьшению количества выполняемых системных вызовов, но также увеличивают совокупное использование памяти процессом сервера.

Замечание: если вы запустите версию Mathopd, использующую sendfile(), размеры буферов по умолчанию будут слишком большими и вам понадобится уменьшить их.

#### InputBufSize = 2048

Буфер ввода содержит полный набор заголовков, отправленных клиентом. Поэтому он должен быть достаточно большим, чтобы вместить все эти заголовки. По умолчанию используется значение 2048, обычно его бывает достаточно и не требуется менять.

#### ScriptBufSize = 4096

Сервер использует два буфера для сценариев CGI: один для данных, переданных в сценарий, и второй для данных, поступающих из сценария. Рекомендуется чтобы ScriptBufSize был равен или больше чем InputBufSize. Также ScriptBufSize должен иметь размер по меньшей мере на шестьдесят байт меньше чем BufSize, чтобы оставить место в выходном буфере для разделителей "кусочков".

#### NumHeaders = 100

Это ключевое слово имеет двойное назначение.

Mathopd отслеживает заголовки HTTP, которые отправил клиент на обработку дочернему процессу. Поскольку каждый из этих параметров должен где−то храниться, фиксированный объём памяти выделяется отдельно. Количество заголовков HTTP, которое действительно хранится, задаётся значением NumHeaders. Если клиент отправил больше заголовков, они всё−же будут обработаны сервером, но они не будут доступны в качестве переменных окружения.

Это ключевое слово имеет дополнительное назначение: оно определяет максимальное количество заголовков, которое может отправить сценарий CGI. Будет ошибкой отправлять из сценария большее количество заголовков.

### Управление ожиданием

#### ScriptTimeout = 60

Этот таймаут определяет как долго, в секундах, сценарий может работать без порождения какого−либо вывода.

#### Timeout = 60

Mathopd отключает соединения, простаивающие слишком долго. Простой в данном случае означает ’отсутствие принимаемых или передаваемых данных’. Можно увеличить или уменьшить время ожидания, добавив ключевое слово Timeout. Значение таймаута указывается в секундах.

#### Wait = 60

Значение ’Wait’ представляет время в секундах, которое сервер должен ожидать запрос от клиента.

Секция LogFormat
----------------

Это ключевое слово определяет порядок полей в файле журнала. Каждая строка файла журнала состоит из нескольких разделённых табуляциями полей. Содержимое каждого поля определяется тем, что находится внутри блока LogFormat. Например, если указать `LogFormat { CTime URI }`, то первое поле в файле журнала соответствует дате и времени запроса, а второе поле соответствует запрошенному в это время клиентом URI.

По умолчанию порядок полей файла журнала следующий:

* Ctime
* RemoteUser
* RemoteAddress
* RemotePort
* ServerName
* Method
* Uri
* Status
* ContentLength
* Referer
* UserAgent
* BytesRead
* BytesWritten

В дополнение к вышеуказанным, доступны также следующие поля:

* LocalAddress
* LocalPort
* Version
* QueryString
* TimeTaken
* MicroTime

### ContentLength

Общий размер ресурса, запрошенного клиентом.

### Ctime

Текущее время в формате ’C’ (например, Sun Mar 30 21:44:52 2003.)

### LocalAddress

Локальный Internet−адрес соединения.

### LocalPort

Номер порта сервера.

### Method

Метод запроса клиента, обычно GET.

### MicroTime

Время, измеренное в секундах с микросекундной точностью, начиная с 1 января 1970 года 00:00:00 по координированному универсальному времени (UTC) (Иначе говоря − это то, что возвращает системный вызов gettimeofday()).

### QueryString

Строка запроса (часть, за которой следует ’?’ в запрошенном URI), если есть.

### Referer

Значение заголовка ’Referer:’ отправляемого клиентом. Иногда это бывает URL, содержащий ссылку на текущий запрос.

### RemoteAddress

Internet−адрес клиента.

### RemotePort

Номер порта соединения со стороны от клиента к серверу.

### RemoteUser

Имя пользователя, отправленное клиентом для запроса, требующего авторизацию и которое было успешно аутентифицировано.

### ServerName

Значение заголовка ’Host:’, отправленное клиентом (больше или меньше).

### Status

Трёхцифровой код статуса HTTP для данного запроса.

### TimeTaken

Время, выделенное для выполнения запроса. Время отсчитывается начиная с первого принятого от клиента байта или от момента подключения клиента.

### Uri

URI запрошенный клиентом (за исключением строки запроса, если она есть).

### UserAgent

Значение заголовка ’User−Agent:’, отправленное клиентом. Оно сожет содержать или не содержать строку, с помощью которой можно идентифицировать веб−браузер.

### Version

Версия HTTP, запрошенная клиентом.

Секция Server
-------------

Ключевое слово Server настраивает физический сервер, то есть сокет TCP. Некоторые параметры TCP могут быть настроены (смотри Address и Port.) Внутри блока сервера могут быть определены ’виртуальные’ серверы, на которые влияет всё сказанное.

### Address = 0 (любой адрес)

Если вы хотите, чтобы сервер ожидал подключений на указанном адресе, а не на любом из адресов, воспользуйтесь этим ключевым словом. Например:

    Server {
        Address 127.0.0.1
    }

### Port = 80

Если вы хотите, чтобы Mathopd запускал сервер на другом порту, а не на порту http по умолчанию, которым является порт 80, воспользуйтесь объявлением Port. Например:

    Server {
        Port 8080
    }

### Backlog = 128

Если все соединения используются и простаивающие соединения отсутствуют, то mathopd не будет пытаться принимать новые соединения. В то же время операционная система может удерживать новые соединения, в этом случае они будут подхвачены mathopd’ом, как только появятся простаивающие соединения. Количество соединений, которые могут "висеть в воздухе" таким способом, определяется параметром Backlog. Обычно менять это количество не требуется.

Секция Virtual
--------------

Ключевое слово ’Virtual’ открывает блок виртуального сервера. Блоки Virtual могут быть объявлены глобально или внутри блока server. Глобальные блоки virtual наследуются всеми последующими серверами.

### AnyHost

Если виртуальный сервер имеет это ключевое слово, то виртуальный сервер совпадёт с любым узлом, которого клиент указал в заголовке. Другие виртуальные серверы, имеющие собственные имена узла, тоже будут проверяться, так что виртуальный сервер с ’AnyHost’ будет использоваться в последнюю очередь. Обратитесь также к обсуждению раскрытия шаблонов в ключевом слове ’Location’.

### Host (строка)

Виртуальный сервер имеет ноль или более имён. Для указания имени виртуального сервера используйте ключевое слово ’Host’. Для каждого виртуального сервера допускается указывать более одного ключевого слова ’Host’.

### NoHost	

Виртуальный сервер, имеющий ключевое слово "NoHost" будет использоваться в том случае, если клиент не отправил в заголовоке поле Host.

Секция Control
--------------

Ключевое слово ’Control’ начинает блок управления. Как следует из имени, он управляет поведением сервера. Фактически ключевое слово ни на что не влияет; всю работу делают ключевые слова внутри блока управления.

Пока блок не содержит директиву Alias, настройки указанные внутри блока управления наследуются всеми последующими блоками, находящимися на том же или более низком уровне.

Блоки управления могут встречаться на трёх различных уровнях. Блоки управления, встречающиеся на верхнем уровне в файле конфигурации называются глобальными блоками управления. Далее, блоки управления могут быть помещены внутри блоков Server. Настройки, определённые здесь локальны для указанного сервера. И наконец, блоки управления могут располагаться внутри блоков Virtual. Эти блоки находятся на нижнем уровне.

Обычно файл конфигурации состоит из одного огромного глобального блока управления с последующей группой виртуальных серверов, каждый из которых содержит маленький блок управления, обычно содержащий директивы Alias и Location.

### Страницы ошибок

#### Admin (строка)

Значение этого ключевого слова, если оно задано, отображается в HTTP−сообщениях об ошибках.

#### Error401File (строка)

Содержимое этого файла будет отображено в том случае, если произошла ошибка ’401’ (not authorized − не авторизованный доступ). Файл может быть сценарием CGI или внешней командой. Если используются сценарии CGI, сценарий отвечает за отправку правильного кода статуса.

#### Error403File (строка)

Содержимое этого файла отображается в том случае, если произошла ошибка ’403’ (forbidden − доступ запрещён). За дополнительной информацией обратитесь к описанию директивы Error401File.

#### Error404File (строка)

Содержимое этого файла отображается в том случае, если произошла ошибка ’404’ (not found − страница отсутствует). За дополнительной информацией обратитесь к описанию директивы Error401File.

### Авторизация

#### Realm (строка)

Если в блоке управления есть это ключевое слово, ресурсы в этом блоке защищены с помощью сочетания имя пользователя−пароль. Ключевое слово Realm должно сопровождаться ключевым словом UserFile. Значение ключевого слова Realm будет передано клиенту в ответе об ошибке ’401’. Его значение может быть отображено веб−браузером в диалоге входа.

#### EncryptedUserFile = Off

Обычно UserFile (обратитесь к описанию ключевых слов Realm и Userfile) содержит пароли в открытом виде. Если вы хотите использовать зашифрованные пароли (например, с помощью программы ’htpasswd’), вы должны задать переключателю EncryptedUserFile значение ’On’ в блоке управления, содержащем директиву UserFile.

#### UserFile (строка)

Блоки управления, ’защищённые’ ключевым словом Realm требуют наличия ключевого слова UserFile. Файл пользователей содержит комбинации всех имён пользователей и их паролей, разрешённые для указанной области (realm). Файл пользователей должен содержать строки, которые выглядят следующим образом:

`имя_пользователя:пароль`

(с именем_пользователя и паролем, конечно же заменёнными настоящими именем пользователя и паролем). Пользовательможет быть указан несколько раз с разными паролями. Файл паролей не имеет отношения к чему−либо из системного файла паролей. Пароли могут быть зашифрованы, но Mathopd должен знать, что они зашифрованы, для этого используется ключевое слово EncryptedUserFile.

### Перенаправление

#### Alias (строка)

Управляющий блок, содержащий ключевое слово Alias, которое используется для трансляции URI в путь на диске. Блок с ключевым словом Alias должен содержать одно или более ключевых слов Location. В общем, mathopd сканирует блоки Control до тех пор, пока не найдёт частичное совпадение части URI из запроса с одним из блоков Alias. Сканирование начинается с виртуального сервера и продолжается вверх. Сканирование прекращается тогда, когда будет найдено совпадение.

Пример:

    Control {
        Alias /
        Location /usr/share/doc/handbook
    }
    Control {
        Alias /boland
        Location /usr/home/boland/www
    }

В примере выше указаны два псевдонима. Отметим, что порядок следования псевдонимов имеет значение: если вы поменяете их местами, могут произойти неожиданные вещи (более точный псевдоним будет сокрыт псевдонимом ’/’).

#### ExactMatch (флаг)

ExactMatch подобна Alias, но используется только при полном совпадении запрошенного URI. Эта опция является скорее уловкой. Изначально она была придумана для того, чтобы запретить пользователям открывать больше чем одну html−страницу на каждом из веб−сайтов. Это можно сделать следующим образом:

    Control {
        IndexNames { index.html }
        Types {
            text/html { html htm }
        }
    }
    Server {
        Virtual {
            Host www.another.example
            Control {
                Alias /
                Location /var/www/www.another.example
                Specials {
                    Dummy { html htm }
                }
            }
            Control {
                Alias /
                Location /var/www/www.another.example
                ExactMatch On
            }
        }
        # другие виртуальные серверы ...
    }

Теперь если кто−то запросит http://www.another.example/, псевдоним будет совпадать дословно, поскольку будет действовать нижний управляющий блок. В другом случае, например если выполнен запрос http://www.another.example/foo.html, псевдоним не совпадёт дословно, поскольку будет использоваться второй управляющий блок снизу. Этот управляющий блок заменяет объявление типа для расширений html и htm, эффективно скрывая эти файлы, в случае если они физически существуют. Отметим, что файлы с расширениями, отличными от html и htm обрабатываются обычным образом, так что вы можете размещать на вашей домашней странице другие файлы, например картинки.

#### Location (строка)

Ключевое слово Location используется в сочетании с ключевым словом Alias. Это два типа местонахождений: физические местонахождения и ’перенаправления’. Физическое местонахождение начинается с косой черты(’/’), а перенаправление − это нечто другое. Когда mathopd обрабатывает запрос, Alias совпадающий с запрошенным URI, отправленным клиентом заменяется на соответствующее местонахождение. Например, в следующей ситуации

    Control {
        Alias /doc
        Location /usr/share/doc/handbook
    }

если клиент запросил URI ’/doc/x11.html’, сервер отправит соержимое /usr/share/doc/handbook/x11.html. Если местонахождение является перенаправлением, сервер отправит ответ со статусом HTTP ’302’, который должен вызвать перенаправление клиента в указанное место. Например:

    Control {
        Alias /secure
        Location https://an.example
    }

В этом примере, если клиент запросит URI ’/secure/test.html’, сервер ответит перенаправлением клиента на ’https://an.example/test.html’.

С одним псевдонимом можно использовать несколько ключевых слов Location. Mathopd будет вращать местонахождения по круговому принципу. Например:

    Control {
        Alias /download
        Location http://mirror1.an.example/download
        Location http://mirror2.an.example/download
        Location http://mirror3.an.example/download
    }

Первый клиент, запросивший что−либо из каталога /download будет перенаправлен на mirrior1.an.example, второй клиент − на mirror2, третий − на mirror3, четвёртый − на mirror1, и так далее.

Дополнение шаблонов: шаблонный символ ’*’ в Location раскрывается в текущее значение заголовка ’host’, отправленное клиентом (после преобразования к нижнему регистру). Это позволяет определять огромное количество виртуальных серверов за раз. Например:

    Server {
        Virtual {
            AnyHost
            Control {
                Alias /
                Location /home/www/*
            }
        }
    }

С такой настройкой, запрос, например http://an.example/foo.html, приведёт к файлу /home/www/an.example/foo.html.

#### PathArgs (флаг)

Если вы хотите перенаправить пользователя на другой веб−сайт, вне зависимости от запрошенного URL, вы можете сделать нечто вроде следующего

    Control {
        Alias /foo
        Location http://www.an.example/foo.html
        PathArgs On
    }

В примере выше при запросе, например /foo/index.html произойдёт перенаправление на http://www.an.example/foo.html. Фактически, *любой* запрос, начинающийся с /foo/ будет перенаправлен на один и тот же URL. Если PathArgs не указан, запрос /foo/index.html будет перенаправлен на http://www.an.example/foo.html/index.html (который, конечно, не имеет смысла).

Ключевое слово PathArgs изначально было создано для решения проблем, относящихся к учёту попаданий. Если у вас имеется веб−сайт, но вы не можете управлять его файлами журналов, вы можете создать скрытые изображения на вашем сайте, которые ведут на сайт учёта статистики. Конечно, это довольно известный процесс. Если сбор статистики запущен на mathopd, он может быть настроен например таким образом:

    Control {
        Alias /
        Location /usr/local/www/tiny−image.png
        PathArgs On
    }

Таким образом, каждый запрос будет возвращать одинаковый ответ, а именно, содержимое tiny−image.png. Если два веб−сайта взаимодействуют, запрошенный URI, который встретится в файле журнала одного сайта может использоваться для учёта попаданий на исходном сайте.

### Настройки CGI-скриптов

#### ChildLog (строка)

Если дочерний процесс, например сценарий CGI, пишет сообщение об ошибке на свой стандартный поток диагностики (файловый дескриптор 2), оно попадёт в файл, обозначенный ключевым словом ChildLog. Если ChildLog не указан, диагностические сообщения будут отброшены.

#### RunScriptsAsOwner = Off

Обычно, если сервер запускается от имени пользователя root и установлен переключатель StayRoot, дочерние процессы запускаются от имени соответствующего пользователя (обратитесь к описанию ключевых слов StayRoot и ScriptUser). Возможно запустить сценарии CGI от имени пользователя, который владеет им заданием переключателя RunScriptsAsOwner. Это не рекомендуется, поскольку можно обмануть mathopd с помощью символических ссылок.

#### ScriptUser (строка)

Если выполняется CGI или внешняя программа, Mathopd поменяет его идентификатор для того, чтобы предотвратить неразумное поведение программы, например убийство сервера. Рекомендуемый способ − задать пользователя для дочернего процесса с помощью ключевого слова ScriptUser. Его аргумент − это имя пользователя, который будет найден в файле паролей системы перед выполнением каждой программы. Пользователь, указанный ScriptUser должен быть кем−то отличным от ’глобального’ пользователя, то есть пользователь указанный в ключевом слове User. Отметим, что для того чтобы CGI работал указанным образом, если mathopd запущен от имени пользователя root, переключатель StayRoot ДОЛЖЕН быть установлен в положение ’On’.

Смотри также: StayRoot.

### Доступ к файлам и каталогам

#### AllowDotfiles = Off

Обычно mathopd в целях безопасности не обслуживает файлы, в пути к которым содержится ’/.’. Если указать опцию AllowDotFiles, ограничения будут ослаблены, но конструкции вида ’/./’, ’/../’ и т.п. по прежнему запрещаются.

#### AutoIndexCommand (строка)

Если сделан запрос каталога, в котором нет файлов, указанных в IndexNames, mathopd напоследок попробует запустить специальный сценарий CGI, чтобы создать список файлов в каталоге. AutoIndexCommand указывает конкретный сценарий. Сценарий должен быть задан полным именем файла.

#### PathInfo = On

Обычно mathopd разрешает запросы подобные /script.cgi/args, в этом случае /args передается в программу script.cgi в качестве информации о пути. Это работает потому, что mathopd отрезает все завершающие компоненты пути до тех пор, пока не будет найден файл. Эта операция может быть довольно дорогостоящей и в большинстве случаев не требуется. Хуже однако, если произойдёт запрос, например /a/b/c/d/e/f/g/h, так как он приведёт к восьми системным вызовам.

Для отключения поведения ’обрубания’, установите значение PathInfo в Off.

Отметим, что PathInfo по умолчанию находится в положении On для достижения обратной совместимости.

#### SanitizePath = Off

Если этот переключатель установлен для виртуального сервера, Mathop будет отфильтровывать все компоненты пути ’//’, ’/./’ и ’/../’ из URL. Например, запрос

`/foo/bar/../baz/./watnou//weer`

будет интерпретирован как если бы это был запрос

`/foo/baz/watnou/weer`

Отметим, что присутствие этого переключателя в виртуальном каталоге не имеет эффекта. Это работает только на уровне сервера.

Также отметим, что URL вида

`/some/dir/.`
`/some/dir/..`

как эти, URL которые оканчиваются на /. или /.. недопустимы и вернут ошибку, вне зависимости от настройки SanitizePath.

#### UserDirectory (флаг)

Чтобы разрешить каждому пользователю создавать его собственные страницы, воспользуйтесь ключевым словом UserDirectory. Например:

    Control {
        Alias /users
        Location public_html
        UserDirectory On
    }

Например, запрос /users/boland/index.html приведёт к поиску пользователя ’boland’ в файле паролей. Допустим, что домашний каталог пользователя − /home/boland. Тогда обслуживаемым файлом будет /home/boland/public_html/index.html.

Замечание: символ ’~’, используемый в качестве последнего символа в псевдониме, трактуется особым образом. Например:

    Control {
        Alias /~
        Location public_html
        UserDirectory On
    }

Если имеется эта настройка, то /~boland/index.html будет отображаться в /home/boland/public_html/index.html, как и раньше. Это позволяет достичь некоторой совместимости с часто используемой возможностью использовать ’~username’ для страниц пользователей.

### Прочее

#### ErrorLog (строка)

Процесс сервера будет выводить диагностические сообщения в этот файл. Mathopd откроет журнал ошибок в режиме только для записи. Если для этого не хватит прав, программа завершит работу. Отметим, что если значение ErrorLog содержит знак процента (%), имя файла журнала ошибок будет дополнено с использованием конструкций strftime (смотрите также: Log.)

Секция Access
-------------

Настройки по умолчанию наследуются от предыдущих блоков Access.

Блок Access может использоваться для разрешения или запрещения доступа указанным IP−адресам. mathopd имеет разрешающую политику по умолчанию, поэтому если блоки Access отсутствуют, доступ всё равно будет разрешён. Если блоки Access всё−же имеются, убедитесь что вы поместили записи доступа в правильном порядке. mathopd сканирет блоки доступа снизу вверх до тех пор, пока они не подойдут. В данном примере:

    Control {
        Access {
            Deny 0/0
            Allow 127.0.0.1/32
        }
    }

Разрешается доступ для 127.0.0.1, а доступ для остальных запрещается.

### Allow (сеть)

### Deny (сеть)

Секция Clients
--------------

Эта директива аналогична ’Access’, с тем исключением, что она вызывает ’условное совпадение с псевдонимом’ прежде, чем трафик будет заблокирован с сообщением об ошибке ’403 Forbidden’. Вследствие этого, директива может использоваться только в сочетании с блоками Control, содержащими блоки Alias. Чтобы отличить список доступа ’Clients’ от ’обычного’ списка доступа, ключевыми словами, используемыми внутри списка являются ’Apply’ и ’NoApply’, а не ’Allow’ и ’Deny’.

Все сказанное можно проиллюстрировать следующим примером.

    Control {
        Alias /
        Location /usr/share/doc/handbook
    }
    Control {
        Alias /
        Location /usr/share/doc/internal/handbook
        Clients {
            Apply 192.168.57.0/24
        }
    }

В этом примере посетители из сети 192.168.57.0/24 получат содержимое, находящееся в каталоге /usr/share/doc/internal/handbook, в то время как другие клиенты будут видеть содержимое каталога /usr/share/doc/handbook. Отметим, что порядок управляющих блоков имеет значение. Если вы поместите неусловный псевдоним внизу, а не наверху, в первую очередь сработает совпадение с сервером, что предотвратит срабатывание условных псевдонимов.

### Apply (сеть)

### NoApply (сеть)

Секция Specials
---------------

Расширения некоторых файлов могут быть трактованы особым образом, если они помещены в блок ’Specials’. Следующие четыре особых трактовки:

* CGI
* Imagemap
* Redirect
* Dump

Если особенность определена с именем, которое не является одним из указанных выше, файл совпадающий с этой особенностью трактуется как не существующий файл. (Смотри пример ’Dummy’ в описании ключевого слова ExactMatch).

Очень короткое описание четырёх особенностей следует далее.

За описанием CGI обратитесь к файлу cgi.txt. imagemap − довольно древняя концепция. Обычно она больше не используется, но сохраняется по историческим причинам. Файлы redirect просто перенаправляют клиента на URL, содержащийся в файле. Dump отображает некоторую иногда интересную статистику, но в других случаях она практически не используется.

Пример:

    Control {
        Specials {
            CGI { cgi }
            Imagemap { map }
        }
    }

Секция Types
------------

Всё обслуживаемое содержимое должно сопровождаться заголовком ’Content−Type’, который указывает на разновидность содержимого. Исторически для определения типа содержимого HTTP серверы используют расширение имени файла. Например, файл с именем оканчивающимся на ’html’ похож на содержащий HTML, файл с именем оканчивающимся на ’png’ возможно содержит изображение PNG, и так далее. Mathopd следует этому поведению. Расширения файла отображаются в типы данных (значение ’Content−Type’, которое понимают веб−браузеры) с помощью ключевого слова ’Types’. Пример:

    Control {
        Types {
            text/html { html htm }
            text/plain { txt }
            image/jpeg { jpg }
            application/octet−stream { * }
        }
    }

Как можно видеть, тип данных определяется группой расширений, соответствующих этому типу. Особое расширение ’*’ используется для обозначения умолчания: если расширение имени файла не встретится в каком−либо из Types (или Specials или External), то используется тип для ’*’ (если он определён).

Отметим, что на самом деле Mathopd понимает под ’расширением’ просто ’последнюю часть’. Например, файл, который назвается ’flubrdhtml’ считается файлом HTML, хотя на самом деле он не имеет расширения. Это несколько не соответствует заявленной возможности, однако на практике это не столь уж неприятно.

Секция Export
-------------

Некоторые операционные системы требуют, чтобы некоторые переменные окружения имели определённые значения для того, чтобы дочерние процессы работали должным образом. Для экспорта этих переменных в дочерние процессы воспользуйтесь ключевым словом ’Export’. Если вы хотите экспортировать определённые переменные с заведомо известными значениями, воспользуйтесь вместо этого опцией ’PutEnv’. Пример:

    Control {
        Export { TZ LD_LIBRARY_PATH }
    }

Секция External
---------------

Ключевые слова ’External’ определяют набор расширений файлов, которые обрабатываются особым образом. (Смотрите также: Types, Specials.) Если mathopd обрабатывает файл с расширением, совпадающим со значением в блоке ’External’, он запустит внешнюю программу с именем файла, указанным в качестве первого аргумента программы. Перед выполнением mathopd сменит текущий каталог на каталог, содержащий обрабатываемый файл. Пример:

    Control {
        External {
            /usr/bin/perl { .pl }
        }
    }

Таким образом все файлы с именем, оканчивающимся на ’.pl’ будут считаться сценариями CGI, интерпретируемыми /usr/bin/perl.

Можно передать дополнительные аргументы интерпретатору. Например, если вы хотите запускать все сценарии perl с опцией ’-T’, воспользуйтесь следующей конструкцией:

    Control {
        External {
            "/usr/bin/perl -T" { .pl }
        }
    }

Секция ExtraHeaders
-------------------

Используйте это ключевое слово для добавления дополнительного заголовка HTTP. Лучше это можно продемонстрировать на следующем примере.

    Control {
        ExtraHeaders { "Cache−Control: max−age=3600" }
    }

При выполнении этого блока все ответы с кодом статуса 200, будут дополняться следующей строкой:

`Cache−Control: max−age=3600`

Секция PutEnv
-------------

Подобно Export, за исключением того, что переменные окружения определённые здесь должны сопровождаться значением. Например: (довольно глупый)

    Control {
        PutEnv {
            MATHOPD_INVOKED=1
        }
    }

Между именем переменной окружения, знаком равенства и значением не должно быть пробелов. Если значение содержит пробельные символы, всё объявление имя=значение должно быть заключено в двойные кавычки.

Секция IndexNames
-----------------

Любой запрос, оканчивающийся косойчертой (’/’) считается обращением к индексу. Терминология немного путанная, поскольку на самом деле индексы не создаются. Что происходит в случае если mathopd получает запрос URI к каталогу? Этот каталог сканируется в поисках набора файлов, называемых индексами. (Например ’index.html’). Как только файл найден, этот файл будет отправлен клиенту. Пример:

    Control {
        IndexNames { index.html Default.htm }
    }

Отметим, что значение ’IndexNames’ действует на все подлежащие управляющие блоки. Поэтому, если вы однажды определили IndexNames, то позднее его невозможно сбросить.
